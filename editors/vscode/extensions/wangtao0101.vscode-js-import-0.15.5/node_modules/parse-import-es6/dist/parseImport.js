'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.getAllImport = getAllImport;
exports.default = parseImport;

var _parseCommentEs = require('parse-comment-es6');

var _parseCommentEs2 = _interopRequireDefault(_parseCommentEs);

var _parseImportClause = require('./parseImportClause');

var _parseImportClause2 = _interopRequireDefault(_parseImportClause);

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// TODO: make line comment follow the last identifier
// TODO: extract all blockcomment (in new line or not decided by the occupied lines if the comment)
// TODO: we make the comment end of the line if exist the block comment in the begining of the line,
//       follow the first identifier of the line include 'import' 'from'
// TODO: handle there my be sentences between import statement and linecomment begin, low p
// TODO: handle there my be sentences between one line blockcomemnt and import statement, low p

/**
 * (?:import[\s]+) match 'import '
 * ?![\s]import[\s match not contain \simport\s
 * (?:(?![\s]import[\s])[\s\S]) match any char include \n but forward string not contain \simport\s
 */

// eslint-disable-next-line
var importRegex = /(?:import[\s]+)(?:((?:(?![\s]import[\s])[\s\S])*?)from[\s]+)??['|"]([A-Za-z0-9_\-./]*)['|"](?:\s*;)?/g;
/**
 * return all import statements
 * @param {*string} strippedText text without comments
 */
function getAllImport(replaceText, originText) {
    if (originText == null) {
        originText = replaceText; // eslint-disable-line
    }
    var res = null;
    var importList = [];
    // here we must use not replaced text to calculate linestart
    var lineStart = (0, _util.getAllLineStart)(originText);
    while ((res = importRegex.exec(replaceText)) != null) {
        // eslint-disable-line
        var importedDefaultBinding = null;
        var nameSpaceImport = null;
        var namedImports = [];
        var error = 0;
        var moduleSpecifier = res[2];

        if (res[1] != null) {
            var importClause = (0, _util.trimWordSpacing)(res[1]);
            var parseResult = (0, _parseImportClause2.default)(importClause);
            if (parseResult != null) {
                importedDefaultBinding = parseResult.importedDefaultBinding;
                nameSpaceImport = parseResult.nameSpaceImport;
                namedImports = parseResult.namedImports;
            } else {
                error = 1;
            }
        }

        importList.push({
            importedDefaultBinding: importedDefaultBinding,
            nameSpaceImport: nameSpaceImport,
            namedImports: namedImports,
            moduleSpecifier: moduleSpecifier,
            range: {
                start: res.index,
                end: res.index + res[0].length
            },
            loc: (0, _util.mapLocToRange)(lineStart, res.index, res.index + res[0].length),
            raw: originText.substring(res.index, res.index + res[0].length),
            error: error
        });
    }
    return importList;
}

// exculde the first leading comment of the first import, if exist 'flow' 'Copyright' 'LICENSE'
var ignoreComment = /@flow|license|copyright/i;

/**
 * return leading comment list
 * @param {*list<comment>} comments
 * @param {*} the last match leading comment of one import
 * @param {*} beginIndex the potential begin of the comment index of the import
 * @param {*} first whether first import
 */
function findLeadingComments(comments, index, beginIndex, first) {
    var leadComments = [];
    if (first && ignoreComment.test(comments[index].raw)) {
        return leadComments;
    }
    var backIndex = index - 1;
    while (backIndex >= beginIndex && (comments[backIndex].loc.end.line + 1 === comments[backIndex + 1].loc.start.line || comments[backIndex].loc.end.line === comments[backIndex + 1].loc.start.line)) {
        if (first && ignoreComment.test(comments[backIndex].raw)) {
            break;
        }
        backIndex -= 1;
    }
    for (var ind = backIndex + 1; ind <= index; ind += 1) {
        leadComments.push(comments[ind]);
    }
    return leadComments;
}

function findTrailingComments(comments, index, nextImp) {
    var trailingComments = [];
    var forwardIndex = index;
    while (forwardIndex < comments.length - 1 && (comments[forwardIndex].loc.end.line + 1 === comments[forwardIndex + 1].loc.start.line || comments[forwardIndex].loc.end.line === comments[forwardIndex + 1].loc.start.line)) {
        forwardIndex += 1;
    }
    for (var ind = index; ind <= forwardIndex; ind += 1) {
        trailingComments.push(comments[ind]);
        /**
         * check if the comment is next to the nextImp,
         * if true, put these comments into leading comments of next imp
         */
        if (nextImp && comments[ind].loc.end.line + 1 >= nextImp.loc.start.line) {
            return [];
        }
    }
    return trailingComments;
}

function getIdentifierLoc(identifier, regexp, imp, replaceImpRaw, lineStart, type) {
    var escapeString = regexp.replace(/\$/g, '\\$');
    var match = new RegExp(escapeString).exec(replaceImpRaw);
    var length = match[0].length - match[1].length;
    var start = match.index + length + imp.range.start;
    var end = start + match[2].length;
    return {
        identifier: identifier,
        loc: (0, _util.mapLocToRange)(lineStart, start, end),
        range: {
            start: start,
            end: end
        },
        type: type
    };
}

function getAllIdentifierLoc(imp, originText, replaceImpRaw) {
    var identifierList = [];
    var lineStart = (0, _util.getAllLineStart)(originText);
    identifierList.push(getIdentifierLoc('import', '^((import)[\\s,]+)', imp, replaceImpRaw, lineStart, 'Import'));
    if (imp.importedDefaultBinding != null) {
        identifierList.push(getIdentifierLoc(imp.importedDefaultBinding, '[\\s]+((' + imp.importedDefaultBinding + ')[\\s,]+)', imp, replaceImpRaw, lineStart, 'ImportedDefaultBinding'));
    }
    if (imp.nameSpaceImport != null) {
        var alias = imp.nameSpaceImport.split(' as ')[1];
        identifierList.push(getIdentifierLoc(imp.nameSpaceImport, '[\\s,]+((\\*\\s+as\\s+' + alias + ')[\\s,]+)', imp, replaceImpRaw, lineStart, 'NameSpaceImport'));
    }
    imp.namedImports.forEach(function (id) {
        var alias = id.split(' as ');
        if (alias[1] == null) {
            identifierList.push(getIdentifierLoc(id, '[\\s,{]+((' + id + ')[\\s,}]+)', imp, replaceImpRaw, lineStart, 'NamedImports'));
        } else {
            identifierList.push(getIdentifierLoc(id, '[\\s,{}]+((' + alias[0] + '\\s+as\\s+' + alias[1] + ')[\\s,}]+)', imp, replaceImpRaw, lineStart, 'NamedImports'));
        }
    });
    if (imp.importedDefaultBinding != null || imp.nameSpaceImport != null || imp.namedImports.length !== 0) {
        /**
         *  Specialï¼š import {Component}from 'react'
         */
        identifierList.push(getIdentifierLoc('from', '[\\s}]+((from)[\\s,]+)', imp, replaceImpRaw, lineStart, 'From'));
    }
    identifierList.push(getIdentifierLoc(imp.moduleSpecifier, '[\\s]+[\\\'\\"]((' + imp.moduleSpecifier + ')[\\\'\\"])', imp, replaceImpRaw, lineStart, 'ModuleSpecifier'));
    return identifierList;
}

function mapCommentsToIdentifier(comments, imp, originText, replaceImpRaw) {
    var identifierList = getAllIdentifierLoc(imp, originText, replaceImpRaw);
    return comments.map(function (comment) {
        // eslint-disable-line
        for (var index = 0; index < identifierList.length; index += 1) {
            var identifier = identifierList[index];
            if (identifier.loc.end.line === comment.loc.start.line) {
                /**
                 * comment before identifier e.g.
                 * /*i am a comment *\/ import a from 'aa';
                 * Then, this comment belong to import identifier
                 */
                if (comment.range.end < identifier.range.start) {
                    return Object.assign(comment, {
                        identifier: identifier
                    });
                }
                /**
                 * if there has same identifier in the same line,
                 * if the comment is between the two ,then the comment belongs to first comment
                 * e.g.
                 * import a from 'aa'; /*asf*\/ import b from 'bb'; the comment belongs to first comment
                 */
                if (index + 1 < identifierList.length && identifierList[index + 1].loc.end.line === comment.loc.start.line && identifierList[index + 1].range.start < comment.range.start) {
                    continue; // eslint-disable-line
                    // next loop it maybe go to else branch
                } else {
                    return Object.assign(comment, {
                        identifier: identifierList[index]
                    });
                }
            }
            /**
             * comment can't find identifier in the same line
             * e.g.
             * import
             * //i am a comment
             * a from 'aa'
             */
            if (identifier.loc.start.line > comment.loc.end.line) {
                return Object.assign(comment, {
                    identifier: identifierList[index]
                });
            }
        }
    });
}

function mapCommentsToImport(imp, beginIndex) {
    var comments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var first = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var nextImp = arguments[4];
    var originText = arguments[5];
    var replaceImpRaw = arguments[6];

    var leadComments = [];
    var trailingComments = [];
    var middleComments = [];
    var index = void 0;
    for (index = beginIndex; index < comments.length; index += 1) {
        var comment = comments[index];
        if (comment.loc.end.line + 1 === imp.loc.start.line
        // treat blockcomment before import(in same line) as leading comment
        // e.g /*asdfasdf
        //     asdf*/ import ...
        || comment.loc.end.line === imp.loc.start.line && comment.loc.start.line < imp.loc.start.line) {
            // look forward for the last match comment
            while (index + 1 < comments.length && comments[index + 1].loc.end.line + 1 === imp.loc.start.line) {
                index += 1;
            }
            leadComments = findLeadingComments(comments, index, beginIndex, first);
        }
        if (comment.loc.start.line === imp.loc.end.line + 1
        // treat blockcomment after import(in same line) as trailing comment
        // e.g import ... /*asdfasdf
        //     asdf*/
        || comment.loc.start.line === imp.loc.end.line && comment.loc.end.line > imp.loc.end.line) {
            trailingComments = findTrailingComments(comments, index, nextImp);
            // skip the trailingComments, there will make bug if multiple comments in same line
            if (trailingComments.length !== 0) {
                index += trailingComments.length - 1;
            }
        }
        /**
         * find middle comment
         */
        if (comment.loc.start.line >= imp.loc.start.line && comment.loc.end.line <= imp.loc.end.line) {
            middleComments.push(comment);
        }

        // (comment.loc.start.line == imp.loc.end.line + 1) must have been processed before
        if (comment.loc.start.line >= imp.loc.end.line + 1) {
            break;
        }
    }

    if (imp.error === 0) {
        middleComments = mapCommentsToIdentifier(middleComments, imp, originText, replaceImpRaw);
    }
    return [Object.assign({}, imp, {
        leadComments: leadComments,
        trailingComments: trailingComments,
        middleComments: middleComments
    }), index];
}

function parseImport(originText) {
    var comments = (0, _parseCommentEs2.default)(originText, { comment: true, range: true, loc: true, raw: true }).comments;
    var replaceText = (0, _util.replaceComment)(originText, comments);
    var imports = getAllImport(replaceText, originText);

    // TODO: filter all wapper statement like '/', '"', "`", commented import statement has been removed

    var pickedImports = [];
    var commentIndex = 0;
    imports.forEach(function (imp, index) {
        var _mapCommentsToImport = mapCommentsToImport(imp, commentIndex, comments, index === 0, imports[index + 1], originText, replaceText.substring(imp.range.start, imp.range.end)),
            _mapCommentsToImport2 = _slicedToArray(_mapCommentsToImport, 2),
            res = _mapCommentsToImport2[0],
            rIndex = _mapCommentsToImport2[1];

        if (res != null) {
            commentIndex = rIndex;
            pickedImports.push(res);
        }
    });
    return pickedImports;
}